# 字符串、向量和数组

## 命名空间的 using 声明

目前的库函数基本属于命名空间 std,例如 `std::cin、std::cout` 编译器，而 `::` 的含义是：编译器应从操作符左侧名字所示的作用域寻找右侧名字，`std::cin` 的意思就是要使用命名空间 `std` 中的名字`cin`。

如果总写这玩意儿有点烦，所以，通过更简单的途径可以访问到命名空间中的成员，即： `using 声明(using declaration)` ，有了 `using` 声明就无须专门的前缀(`::`)

例如，我们常见的:

`using namespace std;` 所以就无需 `std::cin` `std::cout` 

规定里说：每个 `using `声明引入空间中的一个成员，可以把用到的标准库的名字都以 `using `声明出来.

位于头文件的代码，一般不以`using `声明，这是因为头文件的内容会拷贝到它的文件中去，如果头文件里有某个 `using `声明，那么每个使用了该头文件就都会有声明，对于某些程序来说，由于一些名字，可能会产生冲突。

## 标准库 string

标准库 `string` 表示字符变量呗，使用 `string` 必须含有 `string` 的头文件，即：

````c++
#include<string>
using std::string;
````

### 定义和初始化 `string` 对象

初始化的方式：

| string s1           | 默认初始化，s1 是一个空字符串                |
| ------------------- | -------------------------------------------- |
| string s2(s1)       | S2 是 s1 的副本                              |
| string s2 = s1      | 等价于 s2(s1),s2 是 s1 的副本                |
| string s3 = "value" | 等价于 s3("value"),s3 是字面值 "value"的副本 |
| string s4(n,'c')    | 直接初始化，s7 的内容是 n个 c                |
|                     |                                              |

对于，`n`个 `c`来说，只能用于一个字符，不能用于多个字符。

然后就是一些简单的操作

Os 流 `<<`  is `>>`  `getline(is,s)`,`s.empty()`等等。

又例如逐行获取元素：

````
while (getline(cin,line))
	cout << line<<endl;
return 0;
````

触发 `getline` 函数返回的那个换行符实际上被丢弃了，得到的 `string` 对象并不包含换行符。

`size` 长度，`empty` 是否为空。

`size_type` 对于 `size`来说，返回的实际上是一个 `std::size_type` 类型的值，它是一个无符号的类型的值，而由于现在有了 `auto ` 或者 `decltype`来判断变量的类型。

而由于 `size` 返回的是一个无符号(unsigned) 值，所以如果和某一个负值去比较的话，就会一直 `true` ，无法逃脱。

`string` 类型的比较，`string` 对象相等表示的是它们的长度相等，而且包含的字符也完全相等，对于 `<、>、<=、>= ` 按照两个规则来比较：

1.  长度，长度短的小于长度长的。
2. 如果长度相同，比较第一个不同字符的大小

与 python 不同的是，c++ 不允许直接的直接的字符串类型的相加，

例如

````
string a1 = "hello" + "world";  //错误
````

c++ 需要每一个加法运算中都有一个运算对象是 `string`，例如下面的两个例子:

````c++
string s6  =  s1 + "," + "world";
string s7 = "hello" + "," + s2;
````

s6 可以看作是 `s1` 这个 `string`与`,`形成了一个新的 `string`之后再与 `world`混合，而 `s7` 则不是，由于前面有两个字面值直接相加，这是不被允许的。c++ 中:

> 字符串字面值与 `string`是不同的类型。



### 一个简单的综合小例子

````c++
// 需要加入 `cctype`的头文件
string s("Hello World!!!");
decltype (s.size())  punc_number = 0;		//  auto 和 decltype 都是自动判断变量的类型
for (auto c: s)
	if(ispunct(c)) 
		++ punc_number;     //累加标点符号
cout << punc_nuber  << endl;     //输出标点符号的值
````

上面就是用到了循环输出，与 `python` 的遍历字符串一致吧！然后累加标点符号的值。

而也可以稍稍修改一下代码，让它成为每个大写字母的字符串

````c++
string s("Hello World!!!");
string *c;
for auto(&c :s) 
     c  = toupper(c);
     cout << s <<endl;
````

这里必须要用引用，相当于给 `s`的每一个字符串和 `c` 绑定在一起，这时候随着`c `改变，那么也就一直在改变 `s` 的值。

### 下标

`python`毕竟是 `c++`  写的，下标访问方式相同，都是`[]`的方括号，并且都以 0 开始计数，这一点，唯独 `MATLAB` 不大一样。如果想要访问最好还是先加一个 `if (!s.empty())`这个方法，确保确实有字符串需要输出。

###  小总结：

对于字符串的处理，最好先加入 `!string.empty()` 做一下判断，避免出现空字符无法读取的情况，可以用 `for   + 引用的方式`循环遍历字符串，也可以采用 `while(...)` 的方法去控制下标去控制字符串。

## 标准库 (vector)

`vector` 表示对象的集合，所有的对象类型都相等，它是一个类模版。

`vector` 是模板而非类型，由 `vector` 生成的类型必定包含 `vector` 中元素的类型，例如：

`vector` 能够容纳绝大多数类型对象作为其元素，但是因为引用 8 是对象，所以不存在引用的 `vector` ，其他大多数（非引用）内置类型和类类型都可以构成 `vector` 对象，甚至 `vector` 可以套娃 `vector`, 某些老式编译器如果需要套娃 `vector` ，需要 `vector<vector<int> > ` 在最外面一层多加一个空格，新版可能不需要？

### 列表初始化

````c++
// 初始化的方法
vector<T> v1;			//	空 vector v1 潜在的元素是 T,有点类似模板
vector<T> v2(v1) ;		    //v2 中包含了所有 v1 的元素
vector<T> v2 = v1		 //  等价于 v2(v1);
vector<T>v2 (n,val);		//等价于 n 个 val 
vector<T> v4(n) 		//   v4 初始化了 n 个重复地执行了值初始化的对象
vector<T> v5(a,b,c)			// 初始化了元素，并且赋值
````



默认初始化 `vector` 对象，从而创建一个指定类型的空 `vector`

````c++
vector<string> svec;      //默认初始化
````

````
vector<int> ivec;            //初始状态为空

vector<int> ivec2(ivec);      // 将 ivec 的元素拷贝给 `ivec2` 
vector<int>ivec2 = ivec;      //  将 ivec 的元素拷贝给 ivec3

````

列表初始化 `vector` 对象

对于列表的初始化可以使用 `vector<string> articles = {"an","an","the"};` 。对于上面的拷贝的方法，大多数情况下可以相互等价地使用，但也并不是一直如此，例如：

1. 使用拷贝初始化时，只能提供一个初试值。
2. 如果提供的是一个类内初始值，只能使用拷贝初始化或使用花括号的形式初始化。
3. 如果提供的是初始元素值的列表，只能将初始值都放在花括号里初始化

拷贝初始化和直接初始化：

*  如果直接用等号，执行的是 *拷贝初始化*，而如果不使用等号，就是直接初始化:

````c++
string a1 = "haha";          //拷贝初始化
string s6("haha");            //直接初始化
````

* 类内初试值：

````c++
struct Sales_data{
	std::string bookNo;
	unsigned unit_sold = 0;
	double revenue  = 0.0 ;
};
````

* 初始化的列表:

````c++
vector<string>  v1{"an","a","the"};
vector<string> v2("an","a","the");         //错误呗
````



* 创建指定数量的元素：

与字符串相同的是： `vector` 对象可以按照以元素数量和元素初始化值来初始化：

````c++
vector<int> ivec(10,-1);
vector<string> svec(10,"hi");
````

* 值初始化

   通常情况下，可以只给 `vector` 对象容纳的元素数量而不用给初试值的元素，然后库就会创建一个 **值初始化的** 元素初值，这个初值是由`vector` 对象中元素的类型决定的。

实际上很简单，比如：

````c++
vector<int>  ivec(10);            // 10 个元素，每个初试值都初始化为0.
vector<string> svec(10);	//	 10 个元素，每个都是空 `string`
````

对于这种初始化的方式有两个限制：

1. 有些类要求必须明确提供初试值。
2. 如果值提供了元素的数量而没有设定初试值，只能用直接初始化。

* 通过括号判断是元素数量还是值

```c++
vector<int> v1(10);
vector<int>v2{10};

vector<int>v3(10,1)
vector<int>v4{10,1}
```

对于圆括号来说，就是直接初试化，给定数量，然后给定了元素初始化了 `vector`,而花括号代表了初始化的值。

书上给的解释是： 圆括号的值是用来构造 `vector` 对象的。例如 `v1` 的初试值说明了 `vector` 对象的容量， `v3` 的初试值则分别标明了 `vector` 对象的容量和元素的初值。

如果使用花括号，则表述为列表初始化 `vector` 对象，例如 `v2` 和 `v4` 

如果初始化时使用了花括号的形式但是提供的值不能用来初始化列表，则考虑用这样的值来构造`vector` 对象，例如，想要初始化一个含有 `string` 对象的 `vector` 对象，此时，就不难区分到底是要初始化 `vector` 对象的元素还是给定的容量来构造 `vector` 对象。

````c++
vector<string> v5{"hi"};
vector<string>  v6("hi");       //	错误
vector<string> v7(10);		//10 个空字符呗
vector<string> v8{10,"hi"};    // 10 个 `hi`
````

### 向 `vector`中添加元素

一般很难直接初始化一个 `vector` ，所以一般都是尾插一些元素，即先初始化一个空 `vector`，然后利用 `vector.push_back()` 向尾部插入元素.

即:

````c++
vector<int> ivec;
for(int i = 0; i <= 99; i ++) 
	vector.push_back(i);
````

这样 `vector `里面就有 0 到 99 这些元素。

**vector 对象高效增长**

> c++ 标准要求 `vector` 对象应该能在运行时高效快速地添加元素。因此既然 `vector` 对象能够高效地增长，则定义 `vector`  对象的时候设定其大小就没有什么必要了。
>
> 对于 c++ 来说，最好是先设空的  `vector` 对象，然后在运行时再动态添加元素，这一做法与 c 和其他大多数语言的内置数组类型用法不同。

 

**向 `vector` 对象添加元素蕴含的编程假定**

高效便捷地向 `vector` 对象中添加元素，很多编程工作被极大简化了，但是这种简化有一个要求:其中一条就是必须确保所写的循环正确无误，特别是在循环有可能改变 `vector` 容量的时候。

于是有一条隐含的要求，其中一条就是：如果循环体内部含有向 `vector` 对象添加元素的语句，则不能使用范围 `for `循环。

### 其他 `vector` 操作

````c++
v,empty()				// 判断是否为空
v.size()				//返回元素个数
v.push_back()			//	尾插元素
v[n]				   //下标访问
v1 = v2					//  v2 拷贝替换 v1 元素
v1 =  {a,b,c,..}			// 列表中元素的拷贝替换 v1 的元素
v1 == v2 				// v1 和 v2 相等且仅当它们的元素数量相同
v1 != v2 			
<=,>=,<,>				// 常规的比较
````

#### 访问 `vector` 对象的元素

与访问 `string` 一样，用循环直接访问，仅访问可以使用 `auto c:vec`，如果需要赋值的话，则需要使用引用。

例如:

````c++
vector<int> v=  {1,2,3,4,5,6,7,8,9};
for(auto &s : v)  
	i * = i;
for (auto s:v) 
	cout <<  s <<end;
````

 

第一个就是把 `s`定义为 引用的类型，那么久可以通过 `s` 给 `v` 赋值，**引用就相当于别名，绑定** 其中的 `s` 的类型由 `auto` 关键字指定。而 `vector` 的 `size(),empty()` 与 `string` 的同名成员功能完全一致。	`empty` 检查 `vector` 对象是否包含元素然后返回值。`size` 则返回 `vector` 的元素个数。

> 要使用 `size_type` 则需要指定其是那种类型定义的，`vector` 对象的类型总是包含着元素的类型。 

````c++
vector<int>:: size_type 		//正确
vector::size_type 			    // 错误
````

相等性符号的运算符和关系运算符也与 `string` 的相应运算符功能一致。两个`vector` 丢像相等，当切仅当它们所含的元素个数相等，而且对应位置的元素值也相同。关系运算符按照字典顺序比较。如果相应位置的元素值都一样，则元素少的 `vector` 小于元素多的 `vector` ；若元素值有区别，则`vector` 对象的大小由第一对不同的值的大小关系决定。

只有当元素值可以比较时(int 与 int ....)，才可以进行比较。

#### 计算 `vector` 对象内对象的索引

索引和 `string` 一样呗，从 0 开始，下标的类型是 `size_type` ，只要 `vector` 对象不是一个常量，就能向下标运算符返回的元素赋值。

例如统计成绩分段：

有一个 `vector`：

````c++
42 65 95 100 39 67 95 76 88 76 83 92 76 93
````

````c++
vector<int> v1 = {42,65,95,100,39,67,95,76,88,76,83,92,76,83};
int numbr = v1.size();
vector<unsigned> scores(11,0);

int i = 0;
while(i < = number)
{
    if(v1[i] < = 100) 
        ++ scores[v1[i] / 10];
    	i ++ ;
}

// 输出
for (auto &s : scores)
    cout  << s  << endl;
````

#### 不能用下标形式添加元素

实际上，空的 `vector` 对象时空的，不能通过下标赋值

````c++
vector<int> ivec;      // 空 vector 对象
for (decltype(ivec.size() ix = 0;  ix ! = 10;  ++ ix)
	ivec[ix] = ix;
````

这样是错误的，因为 `ivec` 这个对象这时候是空的，不存在任何值。只能用 `push_back` 尾插。

> vector 对象以及 (string) 的下标运算符可以用于访问已存在的元素，而不能用于添加元素。
>
> 试图用下标的形式去访问一个不存在的元素将引发错误，这种错误不会呗编译器发现，而是在运行时产生一个不可预知的值。
>
> 通过下标访问不存在的元素的行为非常常见，而且会导致缓冲区溢出 (buffer overflow)
>
> 确保下标合法的一种有效手段就是尽可能使用范围 for 语句。

### 迭代器

可以通过下标运算来访问 `string `对象的字符或者 `vector` 对象的元素，还有另外一种通用的机制，就是迭代器 (iterator) ，类似于指针，迭代器提供对象的间接访问，就迭代器而言，其对象是容器中元素或者 `string` 对象中的元素。使用迭代器可以访问某个元素，迭代器也能从一个元素移动到另外一个元素。迭代器可以指向某个元素，也可以指向容器中尾元素的下一位置；其他都属于无效。

#### 使用迭代器

获取迭代器不使用取址符，这类拥有名为 `begin` 和 `end` 的成员，其中 `begin` 成员负责返回指向第一个元素的迭代器。

````c++
 由编译器 b 和 e 的类型
 // b  表示 v 的第一个元素，e 表示尾元素的下一位置
 auto b = v.begin() ,       e = v.end();     // b 和 e 的类型相同	
````

`end` 成员负责返回指向容器尾元素的下一位置的迭代器，该迭代器指示的是容器的一个根本不存在的 "尾后" 元素。这样的迭代器没有实际含义，仅仅是个标记而已。 `end` 成员返回的迭代器被称作为 **尾后迭代器** ，或者简称为尾迭代器。特殊情况下如果 容器为空，则 `begin `   和 `end` 返回的是同一个迭代器。

一般来说，迭代器的数据的类型是不确定的。使用 `auto` 关键字定义 b 和 e ，这两个变量的类型也就是 `begin` 和 `end` 的返回值类型。

##### 迭代器运算符

下面有一些标，表示迭代器支持的运算。使用 `==` 和 `!=` 来比较两个合法的迭代器是否相等，如果两个迭代器指向的元素相同或者都是同一个容器的尾后迭代器，则它们相等。

````c++
*iter             //返回迭代器 iter 所指元素的引用
iter -> mem     // 解引用 iter 并获取该元素的名为 mem 的成员，等价于 (*iter).mem
++iter  	// 令迭代器指示容器的下一个元素
-- iter            // 指向上一个元素
iter1 ==  iter2		//判断两个迭代器是否相等，如果两个迭代器指示的是同一个元素
````

与指针类似，也能通过解引用迭代器来获取它所指示的元素，执行解引用的迭代器必须合法并确实指示某个元素

例如:

````c++
string s = "Hello";
if(s.begin() != s.end()) 
{
	auto iter = s.begin();
	*iter = toupper(*iter);
	cout << s << endl;
}
````

这里只改变了一个头迭代器指向元素的大小写，如果要多次执行的话还是得循环。

```c++
for(auto iter = s.begin(); iter != s.end() && !isspace(*iter); ++ iter) 
	*iter = toupper(*iter)
```

虽然看起来会有点奇怪，因为 `toupper` 能对一个单词直接处理，但是多学点好像总没错。

> 大多数人习惯用  < 进行数量的判断，但是 c++ 习惯用 !=  来判断。因为标准库容器的迭代器都定义了 `==` 和 `!=`， 但是它们中的大多数都没有定义 < 运算符，因此养成 `!=` 的习惯，就无需刻意在意是哪种容器。

一般无法知道 `string ` 和 `vector` 的  `size_type` 成员到底是什么类型，一般来说也无法知道迭代器的精确类型，而事实上，那些有迭代器的标准库类型使用 `iterator` 和 `const_iterator` 来表示迭代器的类型：

```c++
vector<int> :: iterator it; 
string:: iterator it2;			//能够读写 string 中对象的字符

vector<int>:: const_iterator it3;         // it3 只能读元素，不能写元素
vector<string>:: const_iterator it4;     // it4  只能读元素，不能写元素
```

> 迭代器和迭代器类型
>
> 迭代器这个名次可以值其本身，也可能是指容器定义的迭代器类型，还可能是某个迭代器对象。
>
> 重点理解概念上一组相关的类型，我们认定某个类型是迭代器当且它支持一套操作，这套操作使得我们能够访问容器的元素或者从某个元素移动到另一个元素。
>
> 每个容器都定义了一个 iterator 的类型，该类型支持迭代器概念所规定的一套操作。

`begin` 和 `end` 操作符

`begin` 和 `end` 返回的具体类型由对象是否是常量决定，如果对象是常量，`begin` 和 `end` 返回 `const_iterator`，如果对象不是常量，返回 `iterator` .

```c++
vector<int> v;
const vector<int >cv; 
auto it1 = v.begin();
auto it2 = cv.begin();				
```

如果对象只需操作而无需写操作的话最好使用常量类型。为了便于专门得到 `const_iterator` 的返回类型,c++ 11 新标准类型引入了新函数，分别是 `cbegin` 和 `cend`：

`auto it3=  v.cbegin();`

所不同的是，无论`vector` 对象本身是否是常量，返回值都是 `const_iterator`.

##### 结合解引用和成员访问操作

解引用迭代器可获得迭代器所指的对象，如果该对象的类型恰好是累，就有可能可以进一步访问它的成员，例如，对于一个由字符串组成的 `vector` 对象来说，要检查其是否为空，令 `it` 为该 `vector` 对象的迭代器，只需检查 `it` 所指字符串是否为空就可以了。

````c++
(*it).empty()
````

而这里面的圆括号必不可少，该表达式相当于先对 `it` 解引用，然后解引用的结果再执行运算符，

相当于运算符的优先级的问题

为了简化上述操作，c++ 定义了剪头运算符 (->)。剪头运算符把解引用和访问成员两个操作结合在一起，也就是  `it->` 和 `(*it).mem` 表达的意思相同。

例如，书上举到的 `text` 字符向量存放文本文件中的数据，其中的元素或者一句话或者是一个用于表示段落分段的空字符串。如果有空行则停止 

````
for (auto it  = s.cbegin();
 it != s.cend() && !it->empty();++it) 
 	cout << *it << endl;
````

##### 某些对 vector 对象的操作会使得 迭代器失效

`vector` 虽然可以动态增长，已知的限制，不能在范围 `for` 循环内向`vector` 对象添加元素，另一个限制是任何一种个可能改变 `vector` 对象容量的操作，例如`push_back`，都会使得 `vector` 对象的迭代器失效。

##### 迭代器的运算

迭代器的运算让迭代器每次移动一个元素，所有的标准库容器都支持递增运算的迭代器，同样，也可以利用 `! = ` 和 `==` 比较两个迭代器。

`string` 和 `vector` 的迭代器支持更多额外的运算符，既可以使得迭代器向前移动若干个元素，也支持迭代器跨过多个元素，迭代器也支持关系运算，这些迭代器运算也被称为**迭代器运算** .



`vector` 和  `string` 支持的迭代器类型:

| `iter + n`       | 迭代器加上一个整数仍得到一个迭代器，迭代器指示的新位置与原来相比向前移动了若干个元素。结果迭代器或者指示容器内的一个元素，或者指示容器的下一个位置。 |
| ---------------- | ------------------------------------------------------------ |
| `iter - n`       | 迭代器减去一个整数数组，仍然得到一个迭代器，迭代器指示的新位置与原来相比向后移动了若干个元素。 |
| `iter += n`      | 复合赋值，其实跟变量没啥区别                                 |
| `iter -= n`      | 复合赋值                                                     |
| `iter 1 - iter2` | 两个迭代器相减的结果是它们之间的距离，即，运算符右侧的迭代器向前移动差值个元素得到左侧的迭代器。参与运算的两个迭代器必须指向的是同一个容器的元素或者尾元素的下一位置。 |
| `>、>=、<、<=`   | 迭代器的关系运算符，如果迭代器的容器在另一个迭代器所指位置之前，则前者小于后者。 |



例如，指向 `vector` 对象的中间位置的元素：

````c++
auto mid = vi.begin() + v1.size()/2;
````

如果 `vi` 有 20 个元素， `vi.begin() = 0` 那么 `0 + 10 =10` 得到的就是迭代器的第 11 个元素。

对于 `string` 或者 `vector` 的迭代器来说，除了判断是否相等，还能使用关系运算符 (<、<=、>=、>) 对其进行比较。参与比较的两个迭代器必须合法而且指向 的是同一个容器的元素（或者尾元素的下一个位置）。

#### 使用迭代器运算

使用迭代器运算的经典`二分算法`。二分搜索从有序序列中寻找某个给定的值。

> 二分搜索从序列中的位置开始搜索，如果中间位置的元素就是要找的元素，搜索完成；如果不是，假如这个元素小于要找的元素，则在序列的后半部分继续搜索；假如该元素大于要找的元素，则在序列的前半部分继续搜索。在缩小的范围中计算一个新的中间值，并重复之前的过程，直至找到目标或者没有元素可继续搜索。

````c++
 // 列表必须有序呗
 // beg 和 end 表示搜索的范围
 auto beg = text.begin(), end = text.end();
 auto mid = text.begin() + (end - begin) /2 ;              // 中值点
 
 // 当元素尚未检查并且还没有找到 sought
while(mid != end && *mid != sought)
{
    if(sought < *mid)
    {
        end  = mid;
    }
    else
        beg =  mid + 1;
    mid = beg + (end - beg) /2 ;		//新的重点
}
````

一开始定义了 3个 迭代器 `beg` 指向了第一个元素， `end` 指向尾元素的下一位置，`mid` 指向中间的那个元素。初试情况下，搜索范围是`text` 的 开始到结束。

当进入循环体内部的时候，程序通过某种规则移动 `beg` 和 `end` 缩小搜索的范围，若`mid` 所指的元素大于 `sought` 则 `text` 在前半部分，那么可以把 `end` 用 `mid `代替，反之，则让 `beg`迭代到 `mid + 1` 的位置。

若循环中值，`mid` 或者等于 `end` 或者指向要找的元素。如果 `mid == end` 说明没有找到要的元素。

后续的课后题提到了为什么在二分查找中不使用`mid = (begin + end )/2 ` ，思考了一下，如果直接 `begin  + end` 话容易使得迭代器迭出缓冲区，溢出缓冲区。

### 数组

数组是一种类似于 `vector` 的数据结构，但是其灵活性和权衡性于 `vector` 不同，与`vector` 相似的是，数组也是存放类型相同的对象的容器，这些对象本身没有名字，需要通过所在的位置访问，与`vector` 不同的地方是,数组的大小确定不变，不能随意向数组种添加元素，所以其运行时性能好，但是相应损失了灵活性。

> 如果不清楚元素的确切个数，则使用 `vector`

#### 定义和初始化内置数组

数组是一种复合类型。数组的声明形如 `a[d]` 其中 `a` 是数组的名字， `d` 是数组的维度。维度说明了数组中元素的个数，所以必须大于 0。数组中元素的个数属于数组的一部分，即，维度必须是一个常量表达式。

````c++
unsigned cnt = 42;
constexpr ungisned sz = 42;
int arr[10];
int *parr[sz];
string bad[cnt];
string strs[get_size()];
````

对于 `bad` 来说，由于 `cnt` 是一个无符号的变量，非常量表达式，所以其是错误的定义，而对于 `get_size` 来说，需要其是一个常量，则`strs` 是一个正确的声明。

默认情况下，数组的元素被默认初始化。

和内置类型的变量一样，若在函数内部定义了某种内置的数组，默认初始化会令数组含有维定义的值。

定义数组时必须指定数组的类型，不允许使用 `auto` 关键字推断。

#### 显示初始化数组元素

可以对数组的元素进行列表的初始化，此时可以忽略数组的维度。如果在声明没有致命维度，编译器会根据初试值的数量计算并推断出来；相反，如果指明了维度，那么初始值的数量不应该超过指定的大小。如果维度比提供的初始值数量大，则用提供的初始值初始化考前的元素，剩余的元素会被初始为默认值。

````c++
const unsigned = 3;
int ia1[sz] = {0,1,2};
int a2[] = {0,1,2};
int a3[5] = {0,1,2};
string a4[3] = {"hi",""bye};		//等价于 a4[] = {"hi","bye",""}
int a5[2] = {0,1,2};			//初始值过多
````

#### 字符数组的特殊性

字符数组有额外的初始化形式，可以用字符串字面值对此类数组初始化。当使用这种方式时，需要注意字符串字面值的结尾处还有一个空字符，这个空字符会一样被拷贝进去。

````c++
char a1[] = {'c','+','+'};
char a2[] = {'c','+','+','\0'};
char a3[] = "c++";
const char a4[6] = "Daniel";  
````

第一个数组不会自动含有空字符，而使用字符串的字面值会有空字符串。而对于 `a4` 来说，由于其只有 6 个维度的大小，但是这个字符串字面值已经占有了 6 个维度，没有空间放空字符，就会报错。

#### 不允许拷贝和赋值

不能将数组的内容拷贝给其他数组作为初始值，也不能用数组为其他数组赋值。

```` c++
int a[] = {0,1,2};       //含有 3个整数的数组
int a2[] = a;       	//错误
a2 = a;			//错误，不能直接把数组赋值给另一个数组
````

而 `vector` 容器允许这些操作。

#### 复杂的数组声明

数组能够存放大多数类型的对象，例如，可以定义一个存放指针的数组。又数组本身是对象，所以允许定义数组的指针及数组的引用。定义数组的指针或者数组的引用就复杂一些。

````c++
int *ptrs[10];			//	ptrs 是含有 10 个整型指针的数组
int &refs[10]  =  / *? */  			//	数组不存在引用
int (*Parray)[10] = &arr;			// Parray 指向一个含有10 个整数的数组
int (&arrRef)[10] = arr;			// arrRef 引用一个含有 10个整数的数组
````

c++ 的魅力大概就在这里吧，指针，引用，光速去世。

对于第一条，就是 `10` 个指针， 对于第二条，由于不存在引用的数组，所以这是个错误的声明。 第三条就是定义了 指向 10 个 整数的数组。  第四条，`arrRef` 引用含有 10个整数的数组。

可能会疑惑第二条和第四条有啥区别，因为在默认情况下，类型修饰符从右往左一次绑定，而对于数组来说，由内向外阅读比由右向左豪赌多了。例如第三条 (*Parray) 首先它是一个指针，接下来看右边，说明它是一个指大小为 10 的数组的指针，最后看左边，指向 `int ` 类型。

> 对于数组，由内向外，再观察

同理对于第四条也是。

````c++
int *(&arr)[10] = ptrs;		//array 是数组的引用，该数组还有10 个指针
````

按照由内向外顺序阅读，首先 `array` 是一个引用，然后看右边是一个大小为 10 的数组，最后看左边知道，数组的元素类型是指向 `int ` 的指针。这样，`array` 久是一个含有 10 个 `int` 型指针的数组的引用。

在使用数组下标的时候，通常将其 `size_t` 类型，`size_t` 是一种机器相关的无符号类型，它被设计得足够大以便能够表示内存中任意对象的大小。在 `cstddef ` 定义了`size_t` 类型。

数组的下标的是否在范围之内仍需要自己检查，所谓合理就是在 `0 - 小于数组的大小` 之内，防止数组下标的越界。

### 指针和数组

指针和数组会有紧密的联系，使用数组的时候，编译器会将其转换成数组。

通常情况下，使用取址符来获取指向某个对象的指针，取址可以用于任何对象。数组的元素也是对象，对数组使用下标运算符得到该数组指定位置的元素。

````c++
string nums[] = {"one","two","three" };
string *p = &nums[0];		
````

然而，数组还有一个特性：在很多用到数组名字的地方，编译器都会将其自动替换为一个指向数组首元素的指针; 

````c++
string *p2 = nums;			// 等价于 p2 = &nums[0]
````

相当于 `p2` 这个指针指向了 `num` 数组的第一个元素。

````c++
int ia[] = {0,1,2,3,4,5,6,7,8,9};
auto ia2(ia);			// 错误: i2 是一个指针，不能用 int 值给指针赋值
ia2 = 42;			     // 错误; ia2 是一个指针，不能用 int 值给指针赋值
````

尽管 `ia` 是 10 个整数构成的数组，但是当使用 `ia` 作为初始值时，编译器执行的初始化过程：

````c++
auto ia2(&ia[0]);
````

必须指出的是，当使用 `decltype` 关键字时转换不会发生， `decltype(ia)` 返回的类型是由 10 个整数构成的数组。

//  ia3 是一个含有 10 个整数的数组

````c++
decltype(ia) ia3  = {0,1,2,3,4,5,6,7,8,9};
ia3 = p; 
ia3[4] = i; 
````

#### 指针也是迭代器

指向数组的指针拥有更多的功能，`vector`  和 `string `迭代器支持的运算，数组的指针也全部支持，例如：允许使用递增运算符将指向数组元素的指针指向前移动到下一个位置;

````c++
int arr[]  = {0,1,2,3,4,5,6,7,8,9};
int *p = arr;
++p;
````

用指针也能遍历数组中的元素，但是需要获取到指向数组第一个元素的指针和指向数组尾元素的下一个位置的指针。通过数组名字或者首元素的地址都能够得到指向首元素的指针；

````c++
int *e = &arr[10];
````

arr 是一个有 10个 元素的数组，但是其下标只能到 `9` ，尾元素所在位置的索引是 `9`，接下来那个不存在的元素就是提供地址初始化 `e`， 就像尾后迭代器一样，尾后指针也不指向具体的元素，因此不能对尾后指针执行解引用或者递增的操作。
		利用得到的指针之前的循环，令其输出 `array` 的全部元素

````c++
int array[10] = {0,1,2,3,4,5,6,7,8,9};
int *e = &arr[10];
for (int *b = arr;b!= e; ++b) 	
	cout << *b << endl;
````

#### 标准函数库 `bgein`  和 `end`  

尽管能通过计算得到尾后指针，但这种用法极易出错。也可以用 `begin`  和 `end` 的函数。但是数组不是类类型，所以不存在成员函数，使用它们的正确形式是将数组作为它们的参数：

`````c++
int ia[] = {0,1,2,3,4,5,6,7,8,9};
int *beg = begin(ia);
int *last = end(ia);
`````



`beg` 返回 `array` 的首元素的指针，而 `end` 函数返回的是指向 `ia` 元素的下一位置的指针。这两个函数定义 `iterator` 头文件中。

例如使用指针遍历输出整个数组：

```c++
int array[10] = {0,1,2,3,4,5,6,7,8,9};
int *beg = begin(array);
int *last = end(array);

while(beg != last && beg >=0) 
{
	++beg;
	cout << *beg << endl;
}
```

首先定义了两个名为 `beg` 和 `last` 的指针，其中 `beg` 指向第一个元素，而 `last` 指向尾元素的下一位置， `while ` 语句通过比较 `beg` 和 `end` 来确保能够安全对 `beg` 解引用，如果 `beg`确实指向了一个元素，将其解引用并检查是否为赋值，如果是，则退出循环，否则，就继续循环。

> 一个指针如果指向内置类型数组的尾元素的“下一位置”，则其具备与 `vector` 的 `end `函数返回的迭代器类似的功能。

#### 指针运算

指针也可以执行迭代器的运算，包括 `解引用、递增、比较、与整数相加、两个指针相减` 登，与迭代器一致。

指针 +- 常数，仍为指针。新指针指向的元素与原来的指针相比前进了（后退）了整数位置。

````c++
constexpr size_T sz =5;
int arr[sz] = {1,2,3,4,5};
int *ip = arr;
int *ip2 = ip + 4;
````

ip + 4 的结果仍然是指针，得到的仍然是指针，但是要防指针越界。

两个指针相减的结果是指针之间的距离，参与运算的两个指针必须指向同一个数组当中的元素。

````c++
auto n = end(arr)  - begin(arr);           		
````

两个指针相减，得到的是一种 `ptrdiff_t` 的结果，与 `size_t` 一样，`ptrdiff_t` 也定义在 `cstddef` 。

但是这两个指针都必须指向同一个数组里的元素，或者指向尾后元素。

````c++
int *b = arr; 
*e = b + sz;	// 尾后指针
while(b < e) 
{
	++b; 
}	
````

#### 解引用和指针的交互

指针加上一个整数仍然是一个指针。若指针指向了一个元素，则能够解引用该元素。

````c++
int ia[] = {0,2,4,6,8};
int last = *(ia + 4);  
````

`*(ia + 4)` 指向的是 `ia` 前进 4 个元素后的新地址，解引用该结果指针的效果等于 `ia[4]` ，数组就是指针，没啥毛病。

但是要区分它和 `*ia + 4` 的区别，相当于解引用再加一个常量。

#### 下标和指针

在很多情况下，使用数组的名字其实用的是一个指向数组首元素的指针，之前已经阐述过了！

此时`ia[0]` 是一个使用数组名字的表达式，对数组执行下标运算实际上是对数组元素的指针执行下标运算。

````c++
int i = ia[2];				//  ia 转换成指向首元素的指针。
 					     // ia[2] 得到 (ia+ 2) 的元素。
int *p = ia; 				// p 指向首元素 
i = *(p +2);			     // 解引用	 
````

只要指针指向的是数组中的元素，都可以执行下标运算:

````c++
int *p = &ia[2];
int j = p[1];
int k = p[-2];			//p[-2] 表示 ia[0] 表示的元素
````

标准库类型 `string` 和 `vector` 也能够执行下标运算，但是数组和它们不同。标准库类型限定使用的下标必须为无符号类型，而内置的下标运算没有这样的要求，

#### 多维数组

严格地来说，实际上没有多维数组，通常所说的多维数组，实际上就是数组的数组。

当一个数组元素仍是数组的时候，通常使用两个维度来定义它，一个表示数组本身的大小，另一个表示其元素的大小；

````c++
int ia[3][4];           //大小为 3 的数组，每个元素是含有 4 个整数的数组.就是 3行 4列
// 大小为 10 的数组，它的每个元素都是大小为 20 的元素。
//这些数组的元素是含有30个整数的数组
int arr[10][20][30] = {0};

````

按照由内而外的顺序阅读这类定义，`ia` 是一个含有 3个元素的数组，然后看， `ia` 的元素也有自己的维度， `ia` 的元素本身也有 4 个元素。

同样也可以这样理解 `int arr[10][20][30];` 实际上就是娃套娃套娃，大小为 10 的数组，它的每个元素都是 20 的数组，然后 含有 30 个元素。

##### 多维数组的初始化：

````c++
int ia[3][4] = {
	{0,1,2,3},
	{4,5,6,7},
	{8,9,10,11},
};
````

看起来舒服一些，但是实际上可以直接用

````c++
int ia[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11};
````

来初始化。

与一维数组初始化一样，在初始化多维数组也并非所有元素的值都必须包含在初始化列表之内，如果仅仅像初始化第一额元素

````c++
int ia[3][4] = {{0},{4},{8}};
````

但是如果使用：

````c++
int ix[3][4]  =  {0,3,6,9}
````

表示初始化了第一行的元素，其他都被初始化为 0 。

##### 多维数组的下标引用

使用下标访问多维数组，此时每个维度对应一个下标运算符。

如果表达式含有的下标运算符数量和数组的维度一样，则该表达式的结果是给定类型的元素；反之，如果表达式含有的下标运算符数量比数组的维度小，则表达式将给定索引初的内层数组：

````
ia[2][3] = arr[0][0][0]; 
int (&row)[4] = ia[1];		// row 绑定到 ia 的第二个  4 元素上
````

按照以前 MATLAB 或者 Python 的逻辑，这里的 `arr` 是个 10 行 20 列 30 页的数据，将 `ia` 的 第三行第四列的数据用 `arr` 的第一个元素赋值，而`row` 是一个引用 `ia`第二行 4 个的数据的引用（绑定）。

程序中常会用到嵌套的 `for ` 循环来处理多维数组的元素；

````c++
constexpr sizt_t rowCnt = 3, colCnt = 4;
int ia[rowCnt][colCnt];
for(size_t i = 0; i != rowCnt;++i) {
	// 对于每一列	
	for (size_j = 0;j!= colCnt; ++j){
		//将元素的位置索引作为它的值
		ia[i][j] = i * colCnt + j;
	}
}
````

相当于给了它的下标。

**使用范围 for 语句处理多维数组**

````c++
size_t  cnt = 0;
for (auto &row : ia)
	for(auto &row : row){
		col = cnt;
		++ cnt;
	}
````

通过范围 `for ` （好像和 python for ）差不多。

下面 

````c++
for (const auto & row :ia) 
	for (auto col: row)
		cout << col <<endl;
````

这个循环主要是 io，将最外层循环的控制变量声明称了引用类型。这是为了避免数组被自动转成指针。假设不用引用类型，则循环将变成:

````c++
for (auto row :ia) 
	for (auto col : row)
````

程序就无法正常的编译，像第一循环遍历 ia ， 这些元素实际上是大小为 4 的数组。 因为 row 非引用类型，编译器会将它们初始化为转换成指向数组内首元素的指针，这样的 `row` 实际是 `int *`, 那么内层也就不合法了。

> 使用范围 for 处理多维数组的时候，除了最内层的循环，其他所有循环的控制变量都应该是引用类型。

##### 指针与多维数组

程序使用多维数组的名字的时候，也会自动将其转换成指向该数组首元素的指针（多维数组是数组的数组）。

````c++
int ia[3][4];
int (*p)[4] = ia;		// p 指向含有4个整数的数组，行
p  = &ia[2]; 		    // 最后一行	
````

与单维数组一样，要从括号由内向外读：

````c++
 int *ip[4]			// 整形指针的数组	
 int (*ip)[4]		  // 指针含有 4 个整数的数组
````

c++11 后，通过使用 `auto ` 或者 `decltype`，就可以避免在数组前面加入指针类型；

````c++
// 输出 ia 中每个元素，每个内层数组占一行
// p 指向含有 4 个整数的数组
for(auto p = ia;p != ia + 3;++p)
{	
	for (auto q = *p; q != *p + 4;++q)
		cout << *p << ' ';
	cout <<  endl;
}
````

##### 类型别名简化多维数组的指针

````c++
using int_array = int[4];
typedef int int_array[4];
````

这里相当于将 `int_array` 指定为 `int[4]` 这么一个数组

````c++
//输出 ia 中每个值，每个内层数组各占一行
for(int_array *p = ia; p != ia + 3; ++p) 
{
    for(int *q = *p;q != *p+ 4;++q)
    {
        cout << *q << ' ' ;
        cout << endl;
    }
}
````

程序将类型 4个整形数组成的整数 命名为 `int_array` ，用类型别名 `int_array` 定义外层的循环。

