# 前言

> 准备转行跑路了，先回味回味 c++，遥感的局限还是太大了，在一个没有资源的情况下，却一定要去凑一些东西，感觉语气三年都做无谓的数据了，不如早点转开发保平安，遥感就随缘看看吧，深度学习，学了个寂寞，调包调参侠，有啥意思，后续反正周六和晚上 c++，计组、计网、操作系统。平常打工，遥感有啥新奇的事，深度学习有啥有趣的事就随缘写写呗。
>
> 这个公众号本身就随缘玩的，随缘写的，我开心就好！

在看 Primer c++ 第 5 版，本科的时候 c++ 学了跟没学一样，但是为了数据结构，为了工作，还是得好好学 c++ 呀，虽然不知道有多少遥感的朋友在看这个公众号，但是我决定还是先跑路了。想起了本科室友的哥哥，在空天院学遥感也学计算机转开发跑路去了。我只能说，这几个月下来，我只看到了“学术”上的遥感，看不到任何工业上的遥感，看不到

# 序言

##   经典 cin 和 cout

````c++
#include<iostream>
using namespace std;

int main(){
    std::cout<< "Hello World"<<std::endl;
}
````

经典 `Hello World` ，但是读这本经典的书看到什么现在回去理解总会有不同的感受

`#include<iostream> 库告诉编译器 (compiler)  ` 使用的是 `iostream` 库，和 `\usepackage{}、import ..` 差不多。`iostream` 是头文件

`iostream` 库，包含两个基础类型 `istream` 和 `ostream` 分别表示输入流和输出流。

`<<`运算符接受的是两个运算对象，左侧为 `ostream` 的对象，右侧为打印的值，

对于 `std::cout<<"Hello World"<<std::endl;` 就等价于

````c++
(std::cout<<"Enter two numbers:") << std::endl
````

相当于分别执行了:

````
std::cout<<"Hello World" ;
std::cout<<std::endl;
````

第二个运算符打印 `endl`，被称为操作符，写入 `endl` 表示结束当前行

而对于 `std::` 来说，指出 `cout` 和 `endl` 是定义在 `std` 的命名空间`(namespace)` 中的，命名空间可以避免不经意的定义冲突。
     与 `<<`  对应的就是 `>>` 表示的是，左侧接受一个  `istream` 作为左侧运算对象，接受一个对象为右侧运算对象。

##  注释:

`//` 表示单行注释, `/* */` 表示多行注释，但是注释不能嵌套，

## while 语句

经典的 `i++` 和 `++i` , `i++` 表示先引用 `i` 的值，`i` 再加 1，而 `++i` 表示先进行 `i = i +1` 再将新的值取出。

对于输入不定量的值的时候可以将 `cin` 放在 while 里面，

## 小综合应用呗

````
#include<iostream>
using namespace std;
int main(){
	int currVal = 0, val = 0;
	//如果确实有输入
	if(cin >> currVal){
	int cnt = 1;
	while(cin >> val ){
	if(val == currVal)
	cnt += 1;
	else{
		cout << currVal << " Occurs" << cnt << "times" <<endl; 
		#将输入的变量存储到 currVal 中去
		currVal = val;
		cnt = 1;
		}
	        }
	cout << currVal << "occurs" <<  cnt << "times" << endl;
	}
	reutrun 0;
}
````

但是这个程序有个小 bug，没有经典的 `keyboardinterrupt` ，然后对于同一值 `val` 一直让 `currVal = val` 。

# 基本的变量

对于 c++ 来说，有符号和无符号不能混用 `int a= 1,unsigned b = -1` ，但是 `a * b = 4294967295`.

对于无符号变量来说，它永远不会小于 0 ，所以就牵涉到了 `for` 循环还有 `while `循环里是否先进行减法的问题。

```c++
for (unsigned u  = 10;u  >= 0;u -- ){
    cout << u; 
}
```

由于迭代成 0 之后，然后继续执行 for 语句里面的内容，表达式 `--u ` 从从当 `u `中减去 1，得到的结果 -1 不满足符号的要求，`-1` 被转换成合法的无符号数，如果 `int ` 占 32 位，则当 `u` 等于 0 时， `--u` 的结果会是 `4294967295`,如果使用 `while` 来代替 `for` 循环，则会先进行一次判断，然后再转

> 初始化和赋值是有区别的，初始化只是创建一个变量赋予一个初始值，而赋值是把对象的当前值给擦除。

​	对于 c++ 来说有 `extern` 声明和`定义` 两种形式，而声明的值在函数体内部不能够初始化，例如：

````c++
int main(){
	extern  int i;
	int j = 1;
	i = 1;
}
````

就会报错

而如果在 `main` 函数之外，直接用 `extern int i = 1`;程序能够正常编译运行。

> 变量能够被定义一次，但是可以被多次声明.

如果在多个文件中使用同一个变量，必须将声明和定义分离，变量的定义只能出现在一个文件中，而其他用到该变量的文件必须对其就行申明。却绝对不能重复定义。

### 静态语言

c++ 是一种静态的语言，即，在编译检查阶段，进行类型的检查，如果不支持运算，则程序会报错并且不会生成可执行程序。

而程序越复杂，静态检查就更容易发现问题，前提是编译器知道每一个实体对象的类型，所以，在使用每个对象前必须声明其类型。

对于 c++ 来说，有些规则是不被允许的。

1. 不能连续出现两个下划线。
2. 也不能以下划线紧跟大写字母连头。
3. 定义在函数体外的标识符不能以下划线开头。



### 定义的几条规范：

1. 标识符体现实际的含义
2. 变量名一般用小写开头。
3. 用户自定义的类名一般以大写开头
4. 如果标识符由多个单词组成，单词之间应该有明显的区分， 例如 `student_name`

## 引用

引用一般为左值引用,例如 `int val = 1`, `int &refVal = ival; ` 一般在初始化变量时，变量是被拷贝到新建的对象中。然而定义引用的时候，程序把引用和它的初始值绑定在一起，而并非直接将初始值拷贝给引用，引用将它的初始值一直绑定在一起，所以无法重新绑定到另一个对象，所以引用必须初始化。

> 引用并不是对象，只是为已经存在的对象起另外一个名字。

例如 `int i = 1024, &r = i;` `cout << r <<endl;` 输出的是它的值，`&r` 则是输出的它的地址。而它的地址会与 `i` 的地址一样。
	  由于是绑定， 所以，引用和被引用的对象的类型必须是一致的，同时，引用的必须是一个对象，而非一个常量，例如 `int  &ref4 = 10; ` 就会报错。

而一旦引用，引用和被引用的对象就被绑定在一起，例如:

````
int i , &ref = i;
i = 5;
ref = 10;
cout << i << " "<< ri <<endl; 
````

程序输出的是 `10,10 ` 就说明两者已经被绑定在一起了，即这个引用不是单独的一个对象了。

## 指针

指针应该是最难的了！！当年本科就没学明白， 

> 指针本身就是一个对象，允许对指针进行拷贝和赋值，而指针在其有效时能够指向不同的对象，指针可以不定义初始值。

但是现在回来看指针，一下就看明白了！！

````c++
int ival = 42;
int *p =  &ival;
````

指针指向的是对象的地址，例如：

````c++
int ival = 42;
int *p = &ival;
cout << "p 的地址是  " <<  p <<  "\n" <<  "p 的值是" <<   *p << endl;
````

所以还可以进行套娃，即：

````
int main(){
	int i = 12;
	int *p = &i;
	int *p2 = p;
	//输出的都是值
	cout <<  i <<  "\t" << *p << "\t" <<   *p2 << endl;
}
````

而指针的类型实际上用于它所指向的对象的类型，所以二者必须匹配。

### 指针的值

指针的应该属于四种状态。

1. 指向一个对象。

2. 指向下一个对象所占的空间的下一个位置。

3. 空指针，意味着没有指向任何对象。

4. 无效指针，也就是上述情况的其他值。

     

一旦指针指向了一个对象，就可以`解引`，解引用虽然可以能够改变`指针变量的值`，但是同时也修改了它`指向对象的值`，实际上也是间接的修改了原来`指向的变量`。。

例如

````
int main(){
	int i = 1;
	int *p = &i;
	// p 是一个地址，而 *p 是一个值，相当于解引用
	cout << p << *p << endl;
	
	*p = 0;
	cout << p << *p;
	cout << i
}
````

指针是个很 abstract 的问题，实际上，只需要记住 `*` 是取值的操作，而 `&` 是取地址的操作。在初始化指针变量的时候，实际上，`*p = &i`  就是将这个指针指向了 `i` 的地址，而 `*p` 则代表了一个解引用，能够解出 `i` 的值。

后续就会有一堆的问题，比如，`引用`和 `取址`	符号，还有指针的解引用。

 例如:

````c++
int main(){
    int i = 42;
    int &ref = i;      //引用
    int *p = &i;      //指针指向
    *p = i;  	   //解引用
    int &ref2 = *p;   // 引用指针变量的值
}
````

### 空指针的值

````
int main{
	int *p = nullptr;
	int *p2 = 0;
	// 要用到  <cstdlib> 这个库
	int *p3 = NULL; 

}
````

书上说：新版最好用 `nullptr` 这个方法，尽量同时避免 `NULL` 的方法。

书上也同时建议：

同时初始化所有的指针。

> 因为访问未经初始化的指针引发后果无法预计，造成了程序崩溃，一旦崩溃，就很难再找到出错的位置。



### 其他指针的操作

void* 是一种特殊的指针，可以用于存放任意对象的地址。一个 `*void` 指针存放着一个地址，但是无法知道到底是个什么类型的对象。

利用 `void*` 指针能做的事比较有限；拿他和别的指针比较，作为函数的输入和输出，或者赋值给另一个`void *` 指针，不能直接操作 `void* ` 所指向的对象，因为不知道所指向对象的类型。

同样指针也能够进行判断，但是无法知道是 `0` 值还是空指针

````c++
int main{
    int *p = 0; // 空指针
    int i = 42;
    int *p1 = &i;  
    if(*p)
        cout<< "p指针合法"<<endl;
    else if(*p1){
        cout<< "p1 指针合法"<<endl;
    }
}
````

但是由于空指针的值是 `0` ，在判断是否为 True 或者 False 会报错。

### 复合类型的声明

一条语句能够定义出不同类型的变量，例如:

````c++
int i = 42, *p = &i, &ref = i;
````

在这里即创建了一个 `int` 的变量，也创建了一个指针，也创建了一个引用的变量。

对于定义变量的类型，有不同的方法：

````
//方法1
int* p1, *p2;
//方法2
int *p1;
int *p2
````

 着两种定义 `int` 型指针的方法都可行，但是需要按照一种去写，否则乱则生变？？

指针可以套娃：

````
int i = 2;
int *p = &i;
int **p1 = &p; 

cout << i<< endl;  //直接输出原值的值
cout << "一次指针 p 的地址为: " << p <<  "," << "它的值为:"  << "*p" <<endl;  //一次指针
cout << "二次指针 ** p 的地址为："<< *p  << ","  << "它的值为" << **p <<endl;
````

所以在套娃的时候很容易混乱到底在用地址还是在引用值。



### 指向指针的引用

````
int i = 2*p;
int *&r = p;

r = &i;
*r = 0;
````

指向指针的引用：

这玩意儿看了我半个多小时，一直不理解，看了半天发现之前理解错了，总觉得怪怪的。

其实做了这么些事儿：

1. 创建了一个`int `型的变量和一个 `int ` 型的指针变量。而由于指针本身就是一个对象，能够进行引用，所以,由于要引用指针，所以 `r` 也得是一个指针，不过 `&r` 相当于进行了一个引用。

2. 由于 `r` 还是一个指针的变量，所以需要拿到地址，由于 `r` 这个指针还需要拿到 `i`的地址，这时候 `r` 也指向了 `i` ，这时候, 解引用 `r` 并进行操作就会改指向的值。

     

例如：

````
int main{
	int i = 42;
	int &ref = i; // 引用 i ，这时候 引用的 ref 和 i 已经绑定在一起了，但是实际上并不存在 ref 这个变量
	int *p = ref;   // 所以这样创建指针，就相当于是错误 但是程序 仍能够运行
      // int *p = &ref;   //这样当然可以，因为 ref 这个引用已经和 i 捆绑在一起了。
	cout << "指针指向的值是 " << *p <<endl;
}
````

> 所以从左到右阅读这些定义，是最有效搞清楚这些的办法。

实际上指针变量只是在函数体内部局部修改，没法作用到指针变量。而指针的引用能够作用到原指针变量。

## 常量

````c++
const int bufsize = 512;
bufsize = 1;		//这样是不被允许的，因为它已经被定义为一个常量了
````



### 初始化与 const 

由于 `const` 变量一创建就不能改变，`const` 变量就一定得初始化，这与引用一致。但是 `const` 的值可以是任意一个复杂的表达式。
 		但是 `const` 在默认的情况下，只会在文件内有效，比如，在一个文件中，`bufsize` 是一个 `const` 对象，那么文件就会找到 `bufsize` 然后把他们都赋值成 `512` .

### 在多个文件中共享 `const` 变量

如果想在多个文件中共享同一个常量的话，需要用 `extern` 声明这一功能。

### `const` 的引用

为了把引用绑定到 `const` 上面，可以对常量进行引用。

例如:

````c++
const int ci = 1024;
const int &ref = ci;   //可以这样引用。
````

下面两种方法都是错误的：

````
ref = 42;
int &r2 = ci;
````

无法直接直接修改 ref 那么就无法直接修改，同样由于 常量无法修改，那么其对应的引用也就无法修改。

> 常量引用是对 const 的引用：
>
> 对 `const 的引用` 简称为`常量引用` 

const 引用和 普通的引用还不一样.

### 指针和常量

要想存放常量的地址，只能使用常量的指针：

````c++
int main(){
	const double pi = 3.14;
	const double *p = &pi; 	//正确写法
//	double *p = &pi;	      //错误写法
	*p = 512;	                 // 由于指向常量，无法修改
}
````

### 一个晕晕的例子

````
int i = 0;
int *const p1 = &j;

const int j = 1;
const int *p2 = &j;
````

从左到右去读代码，先找最近的符号，对于 `p1` 来说，最近的是 `const` 说明他是一个常量对象，然后接下来是 `*`,说明它是一个常量指针，最后是一个 `int ` 说明它指向的是一个 `int `类型的数。		而对于 `p2`,最近的是 `*` 说明他它是一个指针，然后是 `const int ` 说明它指向的是一个`int `类型的常量。

接下来就更晕了！

`p1` 是一个常量指针，但是并不意味着它不能修改其所指对象的值，例如：

<img src='./2.png'>

那么，这个常量指针指向的值是 `int `类型，当然可以通过`解引用`的方法修改它的值。

而第二种，由于指向了一个常量的对象，想通过`解引用`的方法去改原始的值，那么其实是不实际的。

<img src='./3.png'>

### 顶层 const 

指针本身是一个对象，它又可以指向另一个对象，指针本身是不是常量以及指针所指的是不是一个常量是两个相互独立的问题, 用  `顶层const` 表示指针本身就是常量，用 `底层 const` 表示指针的对象是一个常量。

这么说有点绕：

其实` 顶层 const` 相当于 *指针是一个常量*，而常量是不能改变的，即这个<font color=red>指针指向的地址不能改变,但是它指向的值却是可以改变的。</font>

<img src='4.png'>

底层 `const`  相当于表示指针指向对象是一个常量，而常量的值是不能改变的，

<img src='./5.png'>

对于 `顶层 const` 还是 `底层 const` 看 `const` 修饰谁，

当然互谅网的广大朋友是这样记得：

`const ` 在 `*` 的坐标，表示指向常量，那么就是底层的 `const` ，指针的地址能改变，而 `const 在 *p` 右边，表示指针是一个常量，指向的地址不能变，但是其地址存的值是能够改变的。



更为一般化： `顶层 const`表示任意对象都是常量，这一点对任何数据都适用，实际上，`顶层 const`就代表了这个 `值 `或者 `地址` 无法改变，例如下面:

````
int i = 0;
int *const p1 = &i;		//顶层 cosnt
const int c1 = 42;		//顶层 const
const int *p2 = &ci;		//可以改变 p2 的值，这是一个底层的 const
const int *const p3 = p2;        //靠右的是顶层 const，靠左的是底层 const
const int &ref = ci;
````

对于第二行和第三行来说，由于限定 `p1` 的前面一个是 `const`说名它是一个常量指针，指针本身是一个地址对象，<font color=red>那么这个地址无法改变久相当于值无法改变</font>font>，<font color=blue>但是这个地址所存放的值是可以改变的</font>font> 

对于第三行的 `c1` 变量来说，它本身就是一个常量，那么它是无法改变其值的，相当于就是一个顶层 `const`.

而对于第四行的 `int *p2` ，它指向的是一个 `int `类型的 `const`常量，指针是一个存放 `int const`的地址变量，即我的地址可以改变，指向了不同的地址，只是无法赋值语句修改这个原有地址存放的值，如是而已。

第五行实际上有两个 const ,靠右的是一个顶层 `const`，其是一个常量的指针，而其指向的对象是一个常量。

而引用实际上就是一个别名的过程，实际上是不存在这种常量引用的，引用不是一个对象，无法让引用恒定的不变。



### 底层 const 和 底层 const 的拷贝问题



 ````c++
int i = 0;
int *const p1 = &i;		//顶层 cosnt
const int ci = 42;		//顶层 const
const int *p2 = &ci;		//可以改变 p2 的值，这是一个底层的 const
const int *const p3 = p2;        //靠右的是顶层 const，靠左的是底层 const
const int &ref = ci;
 ````

`顶层const `和`底层const`存在一个拷贝的问题，顶层`const `基本不受影响，例如：

````
i = ci;
const int &r  = ci;
````

由于拷贝，或者说赋值过程不会改变拷贝对象的值，拷入和拷出的对象是否是常量都没什么影响。

另外一方面，`底层 const` 却有着限制，`底层 const` 说明所指的对象是常量，其所拷入和拷出的对象都必须有相同的`const`资格，或者两个对象的数据类型都能够被转换，非常量可以转换为常量，而常量当然无法转换成非常量了！

例如:

````
int *p = p3;    
p2 = p3;
p2 = &i;			//  int*  能够转化为 const int *
int &r = ci;		      // 普通 int & 不能绑定到 int 常量上去，因为 
const int &r2  = i;
````

由于`p3` 包含`底层const`的定义，即：`const int * const p3`,当你去尝试这样做的时候，会报一个错:

`constant int ` 类型的值不能用于初始化 `int ` 类型。为啥呢，因为 `const int *const p3` 说明了它的地址和指向的值都不能改变，拷贝 `p3` 的时候，可以不在乎它是一个顶层 `const`，但是它指向的是一个常量，而如果 `p3` 能够初始化 `p` 这个指针，那么 `int `这个非常量的变量定义就没有什么意义了。

而对于第二行 `p2=p3` 由于 `p2` 和 `p3` 都是 `底层 const `所以可以相互转化，

而对于 `p2 = &i` 由于 `p2`    是一个指向常量的指针，

对于 `int &r = ci` 由于 `ci` 是一个常量，如果这个式子能够成立，相当于让一个非常量引用指向一个常量对象。

对于 `const int &r2 = i;`  `const int &`可以绑定到一个普通的 `int `上；

##  constexp 和常量表达式 

**常量表达式是指指针不会改变并且在编译过程中就能得到计算结果的表达式** ，字面值属于常量表达式，用常量表达式初始化 `const` 是常量表达式.

````c++
const int max_files = 20;
const int limit = max_files + 1;
int staff_size = 27;
const int sz = get_size();
````

即要满足两个条件：

1. 值不会改变
2. 编译之后就能得到结果。



第一行中，由于是 `const  int `常量，值不会再改变，所以是常量表达式。同理第二行。

而对于第三行的 `int staff_size` ，由于其是一个 `int `类型的变量，所以该表达式不是常量表达式，而对于第四行的常量 `sz`，由于需要编译运行，使用 `get-size` 函数之后才其具体的值，所以它不是常量表达式。

但是在实际中，初始值常常非常量表达式，在这种情况下，对象的定义和使用是两回事。

c++ 11 之后，允许将变量声明为 `constexpr` 类型，以便编译器验证变量的值是否是一个常量表达式。

### 字面值类型：

常量表达式的值需要在编译时就得到计算，因此对声明 `constexpr` 时必须有所限制。类型一般比较简单，值也显而易见，容易得到，就把它们称为 "字面值类型"

算数类型、引用和指针都属于字面值类型。像 `Sales_item、IO 库、string` 类型不属于字面值类型，即不能定义成 `constexpr`,一般在函数体内部的变量并非存在于固定的地址中，所以 `constexpr` 指针不能指向这样的变量，相反，在函数体外的对象其他地址不变，因此能够初始化 `constexpr` 指针，

同时，之后也介绍函数定义一类有效超过函数本身的变量，这类变量和定义在函数体之外的变量一样也有固定的地址，因此 `constexpr` 引用能够绑定到这样的变量上。

### 指针与 `constexpr`

在 `constexpr` 声明中如果定义了一个指针，限定符 `constexpr` 仅仅对指针有效，对指针所指的对象无关.

```c++
const int *p =  nullptr;
constexpr int *q = nullptr;
```

 `p` 是一个指向常量的指针，而 `q` 是一个指针常量，由于 `constexpr` 将其所定义的对象设置成了一个顶层 `const`。

> 书上的
>
> `constexpr const int *p = &i;` 
>
> `constexpr int *p = &j;` 

如果放在函数体里面，就会报错，但是如果放在函数体的外部，就不会报错。就是上面说的函数体内部的变量并非存在于固定的地址，可能是`局部变量` 和 `全局变量` 的关系吧。

## 处理类型

**类型别名(type alias)** 是一个名字，它是某种类型的同义词。

例如：

````c++
typedef double wages;   //wages 是 double 的同义词
typedef wages base, *p; 
````

实际上就是给某种类型的词一个同义词，比如之后就可以用 `base i = 2;` 说明 `i ` 是一个 `double` 类型的变量，相当于取了别名。

### 指针，常量 和 类型别名

如果某个类型别名只带的是复合类型或常量，那么把它用到声明语句里就会产生意想不到的后果。例如：

````c++
typedef char *pstring;
const pstring cstr =0 ;     //cstr 是指向 char 的常量指针
const pstring *ps;
````

上面两条声明的基本数据类型都是 `const pstring`，`const `是对给定类型的修饰，上面的声明可能被容易的想象并且替换掉:

````
const char * cstr = 0;
const char *ps = 0;
````

但是实际上，它们是一个常量的指针， `const` 是修饰它的类型。

````
//并非:
const char *cstr = 0;
````



但是事实上，声明语句用到 `pstring `时，其基本数据类型是指针。因为对于 `*pstring` 来说，它原本是一个指向字符的指针，而加入 `const `相当于它就是一个指向字符的常量指针，而并非上面所想的那样。上面的第二种人是是错误的，认为它是一个指向常量字符串的指针，相当于一个`底层 const`，但是事实上，这种类型别名并没有改变其 原始指针的数据类型。

### auto 类型说明符

在编程中将表达式的值赋值给变量，这就要求声明变量的时候清楚地知道表达式的类型，然而做到这一点并非易事。于是 c++ 11 新标准引入了 `auto` 类型说明符，用它能让编译器替我们分析表达式所属的类型。 `auto` 让编译器通过初试值来推算变量的类型， `auto `编译的变量必须有初试值。

例如：

````c++
auto item = val1 + val2;    // item 初始化为 val1 和 val2 相加的结果
````

这时候编译器就会根据 `val1` 和 `val2` 相加的结果来推断 `item` 的类型。

### 复合类型、常量 和 auto 

编译器推断的 `auto` 类型有时候和初试值的类型不完全一样，编译器会适当改变结果使其更符合初试规则化。

例如引用：

使用引用事使用引用的对象，特别是引用被当作初试值时，真正参与初始化的其实是引用对象的值，这时候，编译器以引用对象的类型作为 `auto` 的类型。

`auto` 一般会忽略掉顶层 `const`，同时底层 `const` 会被保留下来，例如当初试值是一个指向常量的指针时：

````c++
const int ci = i, &cr = ci;
auto b = ci;			// b 是一个整数,(ci 的顶层 const 特性被忽略了)
auto c  = cr;			 //  c 是一个整数,ci 本身是一个顶层 const
auto d = &i;		       // d 是一个整数指针 
auto e = &ci;		        //  e 是一个指向整数常量的指针。
````

 如果希望 `auto` 推出的类型仍是一个 `顶层 const`，则需要明确指出

````c++
const auto f=  ci;					// ci 的推演类型是 int ,f 是 const int
````

还可以将引用的类型设为 `auto` ，此时的原始的初始化规则仍然使用。

`````c++
auto &g = ci;			//g 是一个整形的常量引用，绑定到 ci
auto &h = 42;		        // 错误： 不能为非常量引用绑定字面值
const auto &j = 42;		     // 正确，可以为常量引用绑定字面值
`````

要在一条语句中定义多个变量，符号 `&` 和 `*` 只能从属于某个声明符，而非基本数据类型的一部分，所以初试值必须是同一个类型:

````
auto k = ci, &l = i;       
auto &m = ci, *p = &ci; // 错误, i 是 int 而 &ci 是 const int 
auto &n = i ,*p2 = &ci;
````

## decltype 类型指示符

有时候希望从表达式的类型中推断出要定义的变量的类型，但是不想用该表达式的值初始化该变量。引入了 `decltype`，它返回的是操作数的数据类型。例如：

````c++
decltype(f())  sum  = x;
````

编译器分析表达式并得到它的类型，却不实际计算它的值。

`decltype` 处理顶层`const` 和引用的方式与 `auto` 有些不同，如果 `decltype` 使用的表达式是一个变量，那么 `decltype` 是该变量的类型（甚至包括了顶层 const 和引用）：

````c++
const int ci = 0, &cj = ci;
decltype(ci) x = 0;                 //    x 的类型是 const int 
decltype(cj) y = x;               //  y 的类型是 const int &,y 绑定到变量 x 上
decltype(cj) z;                    //错误， z为一个引用就必须初始化
````

而如果表达式的内容是解引用的操作，则 `decltype` 将得到引用类型，解引用指针可以得到指针所指的对象，同时还可以给这个对象赋值。 `decltype(*p) ` 得到的是 `int &` ,而非 `int `。

而如果在变量的外面加入了 `()`,那么得到的结果永远是 `引用`，而 `decltype(variable)` 结果只有当 `variable `本身就是一个引用时才是引用。

